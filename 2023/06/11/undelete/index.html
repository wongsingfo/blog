<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta name="color-scheme" content="dark light"><meta name="author" content="Chengke"><meta name="description" content=""><meta name="keywords" content=""><title>数字复活：挽救被格式化硬盘中的照片</title><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css"><link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/default.min.css" dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/tokyo-night-dark.min.css"><link rel="stylesheet" href="https://fonts.font.im/css?family=Noto+Serif" as="font"><link href="//cdn.bootcdn.net/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet"><link href="/style/index.css" rel="stylesheet"><meta name="generator" content="Hexo 7.0.0"></head><body><header class="page-header"><nav><ul class="router-list"><li class="nav-item"><a href="/">Home</a></li><li class="nav-item"><a href="/archives/">Archive</a></li><li class="nav-item"><a href="/friends">Friends</a></li><li class="nav-item"><a href="/about">About</a></li><!--li.nav-item 
  a(href='/atom.xml') RSS--></ul><div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div></nav></header><main><section class="main-content"><section class="post-page"><div class="title-bar"><h1>数字复活：挽救被格式化硬盘中的照片</h1><div class="post-info"><span>2023-06-11 17:51:27</span><span class="tags"><a href="/tags/%E5%AE%9E%E9%AA%8C/">#实验</a></span></div></div><article> <div class="content"><p style="text-align: center;"><img src="/images/cover/in_case_of_fire.jpg" alt="一张梗图：如遇火灾，请提交代码后逃离建筑" /><span>一张梗图：如遇火灾，请提交代码后逃离建筑</span></p>
<p>最近在 B 站看了蒋炎岩老师开设的《操作系统》课程，我非常推荐这门课。蒋老师上课的最大特点是直击本质，将复杂的计算机组件抽象为简单的模型。例如，蒋老师将 I/O 设备接口的本质定义为“几组约定好功能的线”，将文件系统比作“磁盘上的数据结构”。这种方法的好处是，即使学生将来忘记了具体的内容，仍然能够从基础概念和蓝图推导和绘制出全貌。</p>
<p>课上有一个与文件系统相关的实验引起了我的兴趣，实验的主要内容是从被格式化的 FAT32 文件系统中恢复图片<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。这就像是一种“超能力”，想象一下，你拍了很多照片，那是你珍贵回忆的记录，有一天，你不小心误删了这些照片，懊悔不已。如果此时能够让这些照片和回忆“起死回生”，那真的太令人欣喜了。现在，我面前有这样一个实验的机会，我很乐意试一试。</p>
<h2 id="恢复任务"><a class="markdownIt-Anchor" href="#恢复任务"></a> 恢复任务</h2>
<p>我们有一个大小为 64 MiB 的 FAT32 文件系统，其中在 <code>/DCIM</code> 目录下进行了很多次照片读写的操作（这意味着文件系统中存在碎片）。在这些操作之后，我们使用命令 <code>mkfs.fat</code> 格式化了文件系统。我们的任务是尽可能多地从这个格式化的文件系统中恢复照片的名称和内容。</p>
<p>恢复的基本原理是：当我们删除文件或者“快速格式化”磁盘时，实际上只是将文件的索引删除，而文件的实际数据仍然存在于磁盘上。因此，只要我们能够找到这些被标记为可用的文件，并恢复它们的索引和数据，就有机会恢复被删除的照片。</p>
<h2 id="恢复流程"><a class="markdownIt-Anchor" href="#恢复流程"></a> 恢复流程</h2>
<h3 id="了解-fat32-存储格式"><a class="markdownIt-Anchor" href="#了解-fat32-存储格式"></a> 了解 FAT32 存储格式</h3>
<p>首先我们要弄明白 FAT32 系统的存储格式。FAT32 包含三个重要的部分：</p>
<ol>
<li>保留区（Reserved Region）</li>
<li>FAT 区（FAT Region）</li>
<li>文件和目录数据区（File and Directory Data Region）</li>
</ol>
<p>结合文档<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，并观察文件系统的内容（这里推荐一个浏览二进制文件的工具 Hexed It<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>），我们能得到下面的关键信息：</p>
<ol>
<li>卷（Volume）的第一个扇区是引导扇区（Boot Sector）和 BPB（BIOS Parameter Block）。从引导扇区我们可以知道每个扇区有 512 个字节（bytes），每个簇（cluster）有 8 个扇区，所以 <strong>簇的大小是 0x1000</strong>。保留区的大小是 0x32 个扇区，也就是说 <strong>FAT 区的开始位置是 0x4000</strong>。一个 FAT 占用 128 个扇区，一共有两个 FAT，还要除去前两个不用的簇，所以 <strong>第一个簇的偏移量是 128 x 512 x 2 + 0x4000 - 2 x 0x1000 = 0x22000</strong>。第二个扇区是文件系统信息（FSInfo）结构，是辅助系统优化的数据，可以忽略。</li>
<li>每个 FAT entry 的大小为 32 位（4 字节），前两个 FAT entry（即 0x4000~0x4008）用于记录系统状态。在被格式化的文件系统中，表示文件占用的 FAT entries 被置为零，这导致我们无法知道某个簇的下一个簇的位置。</li>
<li>根目录位于第三个簇（从零开始计数是编号为 2 的簇），也就是地址是 0x24000。</li>
<li>在格式化后，数据和目录（除去根目录）仍然存在。但是 FAT 的信息没有了，我们需要根据目录项来恢复文件名、文件大小、文件第一个簇的位置，以及根据文件数据的相关性来恢复图片数据。</li>
</ol>
<h3 id="恢复目录项"><a class="markdownIt-Anchor" href="#恢复目录项"></a> 恢复目录项</h3>
<p>由于图片文件都在 <code>/DCIM</code> 目录而不是根目录 <code>/</code> 下，所以在格式化时，根目录被清除了，而图片文件名得到了保留。这样的设计简化了问题。否则，如果图片都放在根目录下，格式化之后就无法找回图片名字了。</p>
<p>现在我们来恢复目录项。首先，我们要找到 <code>/DCIM</code> 目录的第一个簇编号，因为这个目录是整个文件系统中第一个创建的东西，所以它紧跟在下一个可用的簇之后，即编号为 3 的簇。这引出了一个新问题：由于目录下的图片太多了，一个簇无法存储 <code>/DCIM</code> 目录下的所有目录项，同时第二个簇的编号并不是紧跟在第一个簇之后（即编号不是 4），所以现在我们需要猜测哪些簇存放着目录项。我观察到目录项有一个明显特征：在我们的问题中，<code>DIR_Attr</code> 属性只能是 <code>ATTR_LONG_NAME</code>、<code>ATTR_ARCHIVE</code> 或 <code>ATTR_DIRECTORY</code> 中的一个，因此我们可以先假设所有簇都存放着目录项，然后检查 <code>DIR_Attr</code> 属性，如果不满足我们的观察，那么这个簇存储的就是图片数据。这样，排除了非目录项的簇，我们就找到了所有存放目录项的簇。</p>
<p>接下来，我们根据文档<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>的第六章（Directory Structure）和第七章（Long File Name Implementation）的详细描述，就可以恢复所有的图片文件名、图片文件大小和图片第一个簇的编号。在实现过程中，有两个小细节需要注意：</p>
<p>首先，长文件名可能会跨越两个簇的边界，我们可以根据 <code>LDIR_Ord</code> 的值来判断和恢复。由于这种情况出现的次数不多（即一个簇最多出现一次这种情况），所以我偷懒没有实现这部分功能。</p>
<p>其次，已删除的文件可能仍然存在于目录项中。下面的示例中的 <code>0x00025c20</code> 处就是一个例子。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Previous directory entry</span></span><br><span class="line"><span class="attribute">00025bc0</span>: <span class="number">4262</span> <span class="number">006</span>d <span class="number">0070</span> <span class="number">0000</span> <span class="number">00</span>ff ff0f <span class="number">00</span>ac ffff  Bb.m.p..........</span><br><span class="line"><span class="attribute">00025bd0</span>: ffff ffff ffff ffff ffff <span class="number">0000</span> ffff ffff  ................</span><br><span class="line"><span class="attribute">00025be0</span>: <span class="number">0143</span> <span class="number">0036</span> <span class="number">0062</span> <span class="number">0073</span> <span class="number">0075</span> <span class="number">000</span>f <span class="number">00</span>ac <span class="number">6200</span>  .C.<span class="number">6</span>.b.s.u....b.</span><br><span class="line"><span class="attribute">00025bf0</span>: <span class="number">4</span>f00 <span class="number">4400</span> <span class="number">6700</span> <span class="number">5200</span> <span class="number">3300</span> <span class="number">0000</span> <span class="number">5000</span> <span class="number">2</span>e00  O.D.g.R.<span class="number">3</span>...P...</span><br><span class="line"><span class="attribute">00025c00</span>: <span class="number">4336</span> <span class="number">4253</span> <span class="number">5542</span> <span class="number">7</span>e31 <span class="number">424</span>d <span class="number">5020</span> <span class="number">0064</span> <span class="number">2</span>b5a  C6BSUB~<span class="number">1</span>BMP .d+Z</span><br><span class="line"><span class="attribute">00025c10</span>: ac50 cc56 <span class="number">0000</span> <span class="number">2</span>b5a ac50 e115 bec8 <span class="number">0900</span>  .P.V..+Z.P......</span><br><span class="line"></span><br><span class="line"><span class="comment"># An empty file (?)</span></span><br><span class="line"><span class="attribute">00025c20</span>: e534 <span class="number">534</span>e <span class="number">4</span>d42 <span class="number">7</span>e31 <span class="number">424</span>d <span class="number">5020</span> <span class="number">0064</span> <span class="number">275</span>a  .<span class="number">4</span>SNMB~<span class="number">1</span>BMP .d&#x27;Z</span><br><span class="line"><span class="attribute">00025c30</span>: ac50 ac50 <span class="number">0000</span> <span class="number">275</span>a ac50 <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  .P.P..&#x27;Z.P......</span><br><span class="line"></span><br><span class="line"><span class="comment"># Next directory entry</span></span><br><span class="line"><span class="attribute">00025c40</span>: <span class="number">4230</span> <span class="number">0053</span> <span class="number">005</span>a <span class="number">002</span>e <span class="number">0062</span> <span class="number">000</span>f <span class="number">006</span>d <span class="number">6</span>d00  B0.S.Z...b...mm.</span><br><span class="line"><span class="attribute">00025c50</span>: <span class="number">7000</span> <span class="number">0000</span> ffff ffff ffff <span class="number">0000</span> ffff ffff  p...............</span><br><span class="line"><span class="attribute">00025c60</span>: <span class="number">0138</span> <span class="number">0075</span> <span class="number">0047</span> <span class="number">0069</span> <span class="number">0043</span> <span class="number">000</span>f <span class="number">006</span>d <span class="number">5</span>a00  .<span class="number">8</span>.u.G.i.C...mZ.</span><br><span class="line"><span class="attribute">00025c70</span>: <span class="number">6</span>d00 <span class="number">5300</span> <span class="number">5600</span> <span class="number">6600</span> <span class="number">7600</span> <span class="number">0000</span> <span class="number">7700</span> <span class="number">6800</span>  m.S.V.f.v...w.h.</span><br><span class="line"><span class="attribute">00025c80</span>: <span class="number">3855</span> <span class="number">4749</span> <span class="number">435</span>a <span class="number">7</span>e31 <span class="number">424</span>d <span class="number">5020</span> <span class="number">0064</span> <span class="number">2</span>a5a  <span class="number">8</span>UGICZ~<span class="number">1</span>BMP .d*Z</span><br><span class="line"><span class="attribute">00025c90</span>: ac50 cc56 <span class="number">0000</span> <span class="number">2</span>a5a ac50 <span class="number">741</span>b fae9 <span class="number">0</span>f00  .P.V..*Z.Pt.....</span><br></pre></td></tr></table></figure>
<p>一开始遇到这种情况时我很困惑，以为是一个空文件（因为文件大小为零），但是在挂载之后又找不到同样名字的文件。后来我注意到这个目录项的短文件名的第一个字符不是可读的 ASCII 字符，怀疑它可能有特殊含义。在文档中搜索“E5”，果然发现了相关的说明：</p>
<blockquote>
<p>0xE5 indicates the directory entry is free (available). However, 0xE5 is a valid KANJI （注：日本汉字，是书写日语时所使用的汉字） lead byte value for the character set used in Japan. For KANJI character set based names, the value 0x05 is stored in DIR_Name[0] - if required - to represent 0xE5. If the FAT file system implementation reads DIR_NAME[0] = 0x05 and if the character set used is KANJI, it must perform the appropriate substitution in memory prior to returning the name to the application.</p>
</blockquote>
<p>至此，我们已经恢复了所有图片文件的名称、大小和第一个簇的编号。</p>
<h3 id="恢复图片数据"><a class="markdownIt-Anchor" href="#恢复图片数据"></a> 恢复图片数据</h3>
<p>在上一步，我们得到了存放每个图片数据的第一个簇的位置，以及图片的大小。现在我们需要根据这个线索，找出接下来的所有存放某张图片的所有簇。</p>
<p>最简单的想法是假设图片数据是完全连续存储的。然而，在多次对文件系统进行读写操作后，可能会导致系统中存在“碎片”，即图片数据并不完全连续存储。</p>
<p>针对这个问题，蒋老师在作业中给出了提示：针对 bitmap 连续存储像素的特性去判断两个簇是否处于同一张图片。本来我是打算按这个思路来进行的，但是写了一些代码后发现解析 BMP 格式图片文件<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>有点麻烦了。我们不仅需要根据图片文件的头部信息计算像素存储位置的偏移量，还需要考虑用于行间像素对齐的填充字节。</p>
<p>因此，我选择了另一种更简单的实现方式。我的想法是，对于同一张图片的两个局部区域来说，如果它们代表了相似的内容和颜色分布，则它们的直方图很可能是相似的。直方图是用于表示图像中不同颜色或灰度级别出现频率的统计工具。在我们的任务中，每个簇都包含图片局部区域的像素数据。为了简化操作，我们可以直接将每个字节视为灰度级别，而不考虑 RGB 颜色通道。然后，我们可以计算两个直方图的相似度，以确定两个簇是否属于同一张图片。我咨询了 ChatGPT，并最终选择了 Bhattacharyya 距离<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>作为衡量两个直方图相似度的指标。</p>
<p>当然，这种方案存在一些限制。首先，尽管同一张图片的两个局部区域可能具有相似的直方图，但这并不是绝对的，而是取决于局部内容的相似性和差异性。其次，我们只能判断两个簇是否属于同一张图片，而很难确定这两个簇是否相邻。</p>
<h2 id="恢复结果"><a class="markdownIt-Anchor" href="#恢复结果"></a> 恢复结果</h2>
<p>我使用了课程提供的公开样例对代码进行了测试。样例文件系统大小为 64 MiB，包含 97 张图片。我实现的代码可以在恢复被格式化的 FAT32 硬盘中的照片时使用，具体代码请参见<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。以下是主要的恢复结果：</p>
<ul>
<li>文件名恢复成功率：99.0%，达成课程要求的 75% 的目标</li>
<li>图片数据恢复成功率：
<ul>
<li>方案一“假设图片数据是完全连续存储的”：47.4%</li>
<li>方案二“利用直方图判断两个簇是否处于同一张图片”：69.0%，达成课程要求的 50% 的目标</li>
</ul>
</li>
<li>恢复时间：所有操作均在 2 秒内完成，满足时间限制的 10 秒要求</li>
</ul>
<h3 id="成功例子"><a class="markdownIt-Anchor" href="#成功例子"></a> 成功例子</h3>
<p style="text-align: center;"><img src="/images/undelete-success.bmp" alt="Gérôme - Bathers by the Edge of a River" /><span>Gérôme - Bathers by the Edge of a River</span></p>
<h3 id="失败例子-1"><a class="markdownIt-Anchor" href="#失败例子-1"></a> 失败例子 1</h3>
<p style="text-align: center;"><img src="/images/undelete-failure1.bmp" alt="Francois Boucher - Summer Pastoral" /><span>Francois Boucher - Summer Pastoral</span></p>
<p>在这个例子中，图片恢复一半后找不到接下来的簇了。（在 BMP 格式中，像素是按行存储的。每行的像素从左到右依次排列，从图像的<strong>底部</strong>逐行向上存储。）</p>
<h3 id="失败例子-2"><a class="markdownIt-Anchor" href="#失败例子-2"></a> 失败例子 2</h3>
<p style="text-align: center;"><img src="/images/undelete-failure0.bmp" alt="Honoré Daumier - Different Monomanias of Political Madmen" /><span>Honoré Daumier - Different Monomanias of Political Madmen</span></p>
<p>在这个例子中，中间部分的数据没有被正确恢复。结尾部分的数据被拼接到了开头正常恢复的数据后面，由于像素数据没有对齐（包括 RGB 通道数据和纵向坐标），所以颜色有偏差并且图像有偏移。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>通过这次实验，我学习了文件恢复的基本原理和方法，并了解了 FAT32 文件系统的存储格式和相关信息。通过恢复目录项和图片数据，我成功实现了照片的恢复，并利用直方图相似度判断两个簇是否属于同一张图片。实验结果显示，所提出的方法部分达到了恢复的目标。</p>
<p>从实际应用的角度来看，尽管我们提供的代码可以在实验环境中恢复被格式化的 FAT32 硬盘中的照片，但仍然可以说它只是一个玩具级别的工具。虽然 FAT32 是一种兼容性较好的文件系统，在 SD 卡、U 盘等设备中广泛使用，但在真正遇到这种情况时，需要依赖专业的数据恢复软件才能获得可靠的结果。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>操作系统：设计与实现 (2023 春季学期), <a target="_blank" rel="noopener" href="https://jyywiki.cn/OS/2023/labs/M5">M5: File Recovery</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="http://web.archive.org/web/20230612125612/https://jyywiki.cn/pages/OS/manuals/MSFAT-spec.pdf">Microsoft FAT Specification</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://hexed.it/">Hexed It</a>: Browser-based Online and Offline Hex Editor <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/7/75/BMPfileFormat.svg">https://upload.wikimedia.org/wikipedia/commons/7/75/BMPfileFormat.svg</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bhattacharyya_distance">https://en.wikipedia.org/wiki/Bhattacharyya_distance</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://gist.github.com/wongsingfo/40423bdf9875847dd447b72190932e74">https://gist.github.com/wongsingfo/40423bdf9875847dd447b72190932e74</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div></article><div class="copyright-wrapper"><p>Date: 2023-06-11 17:51:27</p><p>Last modified: 2023-07-10 20:25:17</p><p>@ 2022 Chengke</p></div><div class="post-pager"><div class="prev"><a href="/2023/09/24/superliminal/" title="错觉艺术：《超阈限空间》游玩感想">Previous: 错觉艺术：《超阈限空间》游玩感想</a></div><div class="next"> </div></div></section></section></main><footer class="footer-page"><div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span> | Theme</span><a target="_blank" rel="noopener" href="https://github.com/wongsingfo/hexo-theme-instapaper">instapaper</a></div></footer><script src="/scripts/dark.js"></script><script src="/scripts/post.js"></script></body></html>